[LeetCode: 75. Sort Colors](https://leetcode.com/problems/sort-colors/description/#)

### 75. Sort Colors
### 题目描述：

Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

Note: You are not suppose to use the library's sort function for this problem.

Example:

Input: 

[2,0,2,1,1,0]

Output: 

[0,0,1,1,2,2]

Follow up:

A rather straight forward solution is a two-pass algorithm using counting sort.

First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.

Could you come up with a one-pass algorithm using only constant space?

题目大意就是给出一个整型数组，数组中只包含 0，1，2 数字，每个数字的个数不等，希望将这个数组排序，并且不能利用排序接口。

#### <解法一>

这个题目虽然放到 Medium，但是根据它的提示，想出一种暴力做法并不难，时间复杂度 O(n)
```java
class Solution {
    public void sortColors(int[] nums) {
        int len = nums.length;
        int num0 = 0, num1 = 0, num2 = 0;
        
        for (int i = 0; i < len; i++) {
            if (nums[i] == 0) num0++;
            if (nums[i] == 1) num1++;
            if (nums[i] == 2) num2++;
        }
        
        int j = 0;
        for (int i = 0; i < num0; i++) {
            nums[j++] = 0;
        }
        
        for (int i = 0; i < num1; i++) {
            nums[j++] = 1;
        }
        
        for (int i = 0; i < num2; i++) {
            nums[j++] = 2;
        }
    }
}
```

但是这种做法有一个缺陷，现在题目给出的是 0，1，2，但是如果题目给出 0 ~ 100，上面这种思路仍然有效，但是很明显不能这么做。

#### <解法二>

事实上，我们可以利用 counting sort 排序，这样可以解决较大范围的数字。
```java
class Solution {
    public void sortColors(int[] nums) {
        int len = nums.length;
        int[] count = new int[3];
        
        for (int i = 0; i < len; i++) {
            assert(nums[i] >= 0 && nums[i] <= 2);
            count[nums[i]] += 1; // counting sort
        }
        
        for (int i = 1; i < count.length; i++) {
            count[i] = count[i] + count[i - 1];
        }
        
        int[] res = new int[len];
        for (int i = len - 1; i >= 0; i--) {
            res[count[nums[i]] - 1] = nums[i];
            count[nums[i]]--;
        }
        
        for (int i = 0; i < len; i++) {
            nums[i] = res[i];
        }
    }
}
```

但是这样做还是有缺陷，因为计数排序实际上是用空间换时间的一种排序手段，所以如果给出的数字范围太大，那么使用这种方式排序耗费的内存空间就太大了。

#### <解法三>

题目其实期望我们用一次遍历就可以完成排序，前面的做法都是多次遍历，那么怎么才能达到一次遍历就排好序呢？

我们看题目中给出的是三个数字 0，1，2，如果我们采用三路快排的话，选 1 作为 pivot，在第一次 partition 后，数组就会分为小于 1 和 大于 1 的两部分，即 0 都在 1 的左边，2 都在 1 的右边，此时就已经完成了排序，并且只需要遍历一次数组，因为对于这个题目我们只需要一次 partition 即可排序完成。

思路很简单，但是写的时候还是有很多细节需要注意
```java
class Solution {
    public void sortColors(int[] nums) {
        int zero = -1;          // [0...zero] == 0
        int two = nums.length;  // [two...n-1] == 2
        for(int i = 0 ; i < two ; ){
            if (nums[i] == 1)
                i++;
            else if (nums[i] == 2)
                swap(nums, i, --two);
            else { // nums[i] == 0
                assert nums[i] == 0;
                swap(nums, ++zero, i++);
            }
        }
    }
    
    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```